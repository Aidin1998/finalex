// Database configuration integration tests
package test

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap"
	"go.uber.org/zap/zaptest"

	"github.com/Aidin1998/finalex/internal/infrastructure/database"
)

// TestDatabaseConfigIntegration tests database configuration integration with environment variables
func TestDatabaseConfigIntegration(t *testing.T) {
	logger := zaptest.NewLogger(t)
	ctx := context.Background()
	tempDir := t.TempDir()

	t.Run("EnvironmentConfigurationLoad", func(t *testing.T) {
		testEnvironmentConfigurationLoad(t, ctx, logger, tempDir)
	})

	t.Run("ConfigValidation", func(t *testing.T) {
		testConfigValidation(t, ctx, logger, tempDir)
	})

	t.Run("ConfigDefaults", func(t *testing.T) {
		testConfigDefaults(t, ctx, logger, tempDir)
	})

	t.Run("ProductionConfigurationTest", func(t *testing.T) {
		testProductionConfiguration(t, ctx, logger, tempDir)
	})
}

// testEnvironmentConfigurationLoad tests loading configuration from environment variables
func testEnvironmentConfigurationLoad(t *testing.T, ctx context.Context, logger *zap.Logger, tempDir string) {
	// Set environment variables
	originalEnvVars := map[string]string{
		"DB_DRIVER":                   os.Getenv("DB_DRIVER"),
		"DB_MASTER_DSN":               os.Getenv("DB_MASTER_DSN"),
		"DB_MASTER_MAX_OPEN":          os.Getenv("DB_MASTER_MAX_OPEN"),
		"DB_MASTER_MAX_IDLE":          os.Getenv("DB_MASTER_MAX_IDLE"),
		"DB_MASTER_MAX_LIFETIME":      os.Getenv("DB_MASTER_MAX_LIFETIME"),
		"DB_HEALTH_CHECK_ENABLED":     os.Getenv("DB_HEALTH_CHECK_ENABLED"),
		"DB_HEALTH_CHECK_INTERVAL":    os.Getenv("DB_HEALTH_CHECK_INTERVAL"),
		"DB_ENCRYPTION_ENABLED":       os.Getenv("DB_ENCRYPTION_ENABLED"),
		"DB_METRICS_ENABLED":          os.Getenv("DB_METRICS_ENABLED"),
		"DB_BACKUP_DEFAULT_PATH":      os.Getenv("DB_BACKUP_DEFAULT_PATH"),
		"DB_BACKUP_RETENTION_DAYS":    os.Getenv("DB_BACKUP_RETENTION_DAYS"),
		"DB_TEST_DRIVER":              os.Getenv("DB_TEST_DRIVER"),
		"DB_TEST_ISOLATION_ENABLED":   os.Getenv("DB_TEST_ISOLATION_ENABLED"),
		"DB_TEST_TRANSACTIONAL_TESTS": os.Getenv("DB_TEST_TRANSACTIONAL_TESTS"),
	}

	// Cleanup function to restore original environment variables
	defer func() {
		for key, value := range originalEnvVars {
			if value == "" {
				os.Unsetenv(key)
			} else {
				os.Setenv(key, value)
			}
		}
	}()

	// Set test environment variables
	testDBPath := filepath.Join(tempDir, "config_test.db")
	backupPath := filepath.Join(tempDir, "backups")

	testEnvVars := map[string]string{
		"DB_DRIVER":                   "sqlite",
		"DB_MASTER_DSN":               testDBPath,
		"DB_MASTER_MAX_OPEN":          "20",
		"DB_MASTER_MAX_IDLE":          "10",
		"DB_MASTER_MAX_LIFETIME":      "1h",
		"DB_HEALTH_CHECK_ENABLED":     "true",
		"DB_HEALTH_CHECK_INTERVAL":    "60s",
		"DB_ENCRYPTION_ENABLED":       "false",
		"DB_METRICS_ENABLED":          "true",
		"DB_BACKUP_DEFAULT_PATH":      backupPath,
		"DB_BACKUP_RETENTION_DAYS":    "30",
		"DB_TEST_DRIVER":              "sqlite",
		"DB_TEST_ISOLATION_ENABLED":   "true",
		"DB_TEST_TRANSACTIONAL_TESTS": "true",
	}

	for key, value := range testEnvVars {
		os.Setenv(key, value)
	}

	// Create backup directory
	err := os.MkdirAll(backupPath, 0755)
	require.NoError(t, err)
	// Load configuration from environment
	config := &database.DatabaseConfig{}
	err = database.LoadConfigFromEnvironment(config)
	require.NoError(t, err)

	// Validate configuration values using actual DatabaseConfig fields
	assert.Equal(t, testDBPath, config.MasterDSN)
	assert.Equal(t, 20, config.MaxOpenConns)
	assert.Equal(t, 10, config.MaxIdleConns)
	assert.Equal(t, time.Hour, config.ConnMaxLifetime)
	assert.Equal(t, 60*time.Second, config.HealthCheckInterval)
	assert.True(t, config.EnableMetrics)

	// Test backup configuration
	backupConfig := &database.BackupManagerOptions{}
	err = database.LoadBackupConfigFromEnvironment(backupConfig)
	require.NoError(t, err)

	assert.Equal(t, backupPath, backupConfig.DefaultOutputPath)
	assert.Equal(t, 30, backupConfig.RetentionDays)

	// Test database manager creation with loaded config
	dbManager, err := database.NewDatabaseManager(config, logger)
	require.NoError(t, err)

	err = dbManager.Connect(ctx)
	require.NoError(t, err)
	defer dbManager.Close()

	// Verify connection works
	health := dbManager.HealthCheck(ctx)
	assert.True(t, health.Healthy)
}

// testConfigValidation tests configuration validation
func testConfigValidation(t *testing.T, ctx context.Context, logger *zap.Logger, tempDir string) {
	// Test invalid driver
	invalidConfig := &database.DatabaseConfig{
		Driver: "invalid_driver",
		Master: database.ConnectionConfig{
			DSN: "test",
		},
	}

	err := database.ValidateConfig(invalidConfig)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "unsupported database driver")

	// Test missing DSN
	missingDSNConfig := &database.DatabaseConfig{
		Driver: "sqlite",
		Master: database.ConnectionConfig{
			DSN: "",
		},
	}

	err = database.ValidateConfig(missingDSNConfig)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "master DSN is required")

	// Test valid configuration
	validConfig := &database.DatabaseConfig{
		Driver: "sqlite",
		Master: database.ConnectionConfig{
			DSN:         filepath.Join(tempDir, "valid.db"),
			MaxOpen:     10,
			MaxIdle:     5,
			MaxLifetime: 30 * time.Minute,
		},
		HealthCheck: database.HealthCheckConfig{
			Enabled:  true,
			Interval: 30 * time.Second,
			Timeout:  5 * time.Second,
		},
	}

	err = database.ValidateConfig(validConfig)
	assert.NoError(t, err)
}

// testConfigDefaults tests configuration default values
func testConfigDefaults(t *testing.T, ctx context.Context, logger *zap.Logger, tempDir string) {
	// Create minimal config
	config := &database.DatabaseConfig{
		Driver: "sqlite",
		Master: database.ConnectionConfig{
			DSN: filepath.Join(tempDir, "defaults.db"),
		},
	}

	// Apply defaults
	database.ApplyConfigDefaults(config)

	// Verify default values
	assert.Equal(t, 25, config.Master.MaxOpen)
	assert.Equal(t, 5, config.Master.MaxIdle)
	assert.Equal(t, 30*time.Minute, config.Master.MaxLifetime)
	assert.True(t, config.HealthCheck.Enabled)
	assert.Equal(t, 30*time.Second, config.HealthCheck.Interval)
	assert.Equal(t, 5*time.Second, config.HealthCheck.Timeout)
	assert.True(t, config.Metrics.Enabled)
	assert.Equal(t, "database", config.Metrics.Namespace)

	// Test backup manager defaults
	backupOptions := &database.BackupManagerOptions{}
	database.ApplyBackupDefaults(backupOptions)

	assert.Equal(t, "./backups", backupOptions.DefaultOutputPath)
	assert.Equal(t, 7, backupOptions.RetentionDays)
	assert.True(t, backupOptions.EnableMetrics)
	assert.Equal(t, 4, backupOptions.MaxConcurrentBackups)

	// Test test database defaults
	testConfig := &database.TestDatabaseConfig{
		Driver: "sqlite",
	}
	database.ApplyTestDatabaseDefaults(testConfig)

	assert.Equal(t, ":memory:", testConfig.DSN)
	assert.True(t, testConfig.IsolateTests)
	assert.True(t, testConfig.TransactionalTests)
	assert.Equal(t, "on_success", testConfig.CleanupPolicy)
	assert.True(t, testConfig.EnableFK)
}

// testProductionConfiguration tests production-ready configuration
func testProductionConfiguration(t *testing.T, ctx context.Context, logger *zap.Logger, tempDir string) {
	// Create production-like configuration
	config := &database.DatabaseConfig{
		Driver: "sqlite",
		Master: database.ConnectionConfig{
			DSN:         filepath.Join(tempDir, "production.db"),
			MaxOpen:     100,
			MaxIdle:     20,
			MaxLifetime: 1 * time.Hour,
		},
		Slaves: []database.ConnectionConfig{
			{
				DSN:         filepath.Join(tempDir, "slave1.db"),
				MaxOpen:     50,
				MaxIdle:     10,
				MaxLifetime: 1 * time.Hour,
			},
		},
		HealthCheck: database.HealthCheckConfig{
			Enabled:  true,
			Interval: 10 * time.Second,
			Timeout:  3 * time.Second,
		},
		Encryption: database.EncryptionConfig{
			Enabled: false, // Would be true in real production
			Key:     "",    // Would be set from environment
		},
		Metrics: database.MetricsConfig{
			Enabled:   true,
			Namespace: "finalex_db",
			Labels: map[string]string{
				"environment": "production",
				"service":     "trading",
			},
		},
		Sharding: database.ShardingConfig{
			Enabled:  true,
			Strategy: "hash",
			Shards: []database.ShardConfig{
				{
					Name:   "shard_0",
					DSN:    filepath.Join(tempDir, "shard_0.db"),
					Weight: 50,
				},
				{
					Name:   "shard_1",
					DSN:    filepath.Join(tempDir, "shard_1.db"),
					Weight: 50,
				},
			},
		},
	}

	// Validate production configuration
	err := database.ValidateConfig(config)
	require.NoError(t, err)

	// Create database manager with production config
	dbManager, err := database.NewDatabaseManager(config, logger)
	require.NoError(t, err)

	err = dbManager.Connect(ctx)
	require.NoError(t, err)
	defer dbManager.Close()

	// Test production features
	health := dbManager.HealthCheck(ctx)
	assert.True(t, health.Healthy)

	// Test sharding
	if config.Sharding.Enabled {
		shard0 := dbManager.GetShard("test_key_0")
		assert.NotNil(t, shard0)

		shard1 := dbManager.GetShard("test_key_1")
		assert.NotNil(t, shard1)
	}

	// Test metrics collection
	metrics := dbManager.GetMetrics()
	assert.NotNil(t, metrics)
	assert.True(t, metrics.ConnectionPoolStats.OpenConnections > 0)

	// Test backup manager with production config
	backupOptions := &database.BackupManagerOptions{
		DefaultOutputPath:    filepath.Join(tempDir, "prod_backups"),
		RetentionDays:        30,
		EnableMetrics:        true,
		MaxConcurrentBackups: 2,
		CompressionLevel:     6,
		EncryptionEnabled:    false, // Would be true in production
	}

	backupManager := database.NewBackupManager(dbManager.GetDB(), logger, backupOptions)
	assert.NotNil(t, backupManager)

	// Create production backup test
	os.MkdirAll(backupOptions.DefaultOutputPath, 0755)

	// Create test table for backup
	err = dbManager.GetDB().Exec(`
		CREATE TABLE production_test (
			id INTEGER PRIMARY KEY,
			data TEXT NOT NULL,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`).Error
	require.NoError(t, err)

	// Test production backup
	backupOpts := &database.BackupOptions{
		OutputPath:  filepath.Join(backupOptions.DefaultOutputPath, "prod_backup.sql"),
		Format:      "sql",
		Compression: true,
		Metadata: map[string]interface{}{
			"environment": "production",
			"backup_type": "scheduled",
		},
	}

	backupInfo, err := backupManager.CreateBackup(ctx, backupOpts)
	require.NoError(t, err)
	assert.NotNil(t, backupInfo)

	t.Log("Production configuration test completed successfully")
	t.Logf("Database manager created with production settings: MaxOpen=%d, Sharding=%v, Metrics=%v",
		config.Master.MaxOpen, config.Sharding.Enabled, config.Metrics.Enabled)
}
