package userauth

import (
	"context"
	"fmt"
	"time"

	twofa "github.com/Aidin1998/pincex_unified/internal/userauth/2FA"
	"github.com/Aidin1998/pincex_unified/internal/userauth/audit"
	"github.com/Aidin1998/pincex_unified/internal/userauth/auth"
	"github.com/Aidin1998/pincex_unified/internal/userauth/compliance"
	"github.com/Aidin1998/pincex_unified/internal/userauth/encryption"
	"github.com/Aidin1998/pincex_unified/internal/userauth/identities"
	"github.com/Aidin1998/pincex_unified/internal/userauth/kyc"
	"github.com/Aidin1998/pincex_unified/internal/userauth/notification"
	"github.com/Aidin1998/pincex_unified/internal/userauth/password"
	"github.com/Aidin1998/pincex_unified/pkg/models"
	"github.com/google/uuid"
	"go.uber.org/zap"
	"gorm.io/gorm"
)

// ServiceConfig holds configuration for the UserAuth service
type ServiceConfig struct {
	JWTSecret              string
	JWTExpiration          time.Duration
	RefreshTokenSecret     string
	RefreshTokenExpiration time.Duration
	Issuer                 string
	TwoFAGracePeriodDays   int
	EmailConfig            notification.EmailConfig
	SMSConfig              notification.SMSConfig
}

// Service provides unified user authentication and identity management
type Service struct {
	// Core services
	authService         auth.AuthService
	identityService     identities.Service
	kycService          kyc.Service
	auditService        *audit.Service
	notificationService *notification.Service
	passwordService     *password.Service	complianceService   *compliance.ComplianceService
	encryptionService   *encryption.PIIEncryptionService
	twoFAService        *twofa.Service

	// Infrastructure
	tieredRateLimiter *auth.TieredRateLimiter
	logger            *zap.Logger
	db                *gorm.DB
	redis             *redis.Client

	// Configuration
	config ServiceConfig
}

// NewService creates a new unified user authentication service
func NewService(logger *zap.Logger, db *gorm.DB, redisClient *redis.Client, config ServiceConfig) (*Service, error) {
	// Initialize auth service
	authSvc, err := auth.NewAuthService(
		logger,
		db,
		config.JWTSecret,
		config.JWTExpiration,
		config.RefreshTokenSecret,
		config.RefreshTokenExpiration,
		config.Issuer,
		nil, // Rate limiter will be set after creation
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create auth service: %w", err)
	}

	// Initialize other services
	identitySvc := identities.NewService(logger, db)
	kycSvc := kyc.NewService(logger, db)
	auditSvc := audit.NewService(logger, db)
	notificationSvc := notification.NewService(logger, db, redisClient, config.EmailConfig, config.SMSConfig)
	passwordSvc := password.NewService(logger, db, redisClient)
	complianceSvc := compliance.NewService(logger, db, redisClient)
	encryptionSvc := encryption.NewService(logger)
	twoFASvc := twofa.NewService(logger, db, config.Issuer)

	// Create user service adapter for rate limiter
	userService := auth.NewAuthUserService(db)

	// Initialize tiered rate limiter
	tieredRateLimiter := auth.NewTieredRateLimiter(redisClient, logger, userService)

	service := &Service{
		authService:         authSvc,
		identityService:     identitySvc,
		kycService:          kycSvc,
		auditService:        auditSvc,
		notificationService: notificationSvc,
		passwordService:     passwordSvc,
		complianceService:   complianceSvc,
		encryptionService:   encryptionSvc,
		twoFAService:        twoFASvc,
		tieredRateLimiter:   tieredRateLimiter,
		logger:              logger,
		db:                  db,
		redis:               redisClient,
		config:              config,
	}
	return service, nil
}

// AuthService returns the authentication service
func (s *Service) AuthService() auth.AuthService {
	return s.authService
}

// IdentityService returns the identity service
func (s *Service) IdentityService() identities.Service {
	return s.identityService
}

// KYCService returns the KYC service
func (s *Service) KYCService() kyc.Service {
	return s.kycService
}

// TieredRateLimiter returns the tiered rate limiter
func (s *Service) TieredRateLimiter() *auth.TieredRateLimiter {
	return s.tieredRateLimiter
}

// RateLimitMiddleware returns the rate limiting middleware
func (s *Service) RateLimitMiddleware() gin.HandlerFunc {
	if s.tieredRateLimiter == nil {
		// Return no-op middleware if rate limiter is not available
		return func(c *gin.Context) {
			c.Next()
		}
	}
	return s.tieredRateLimiter.Middleware()
}

// SetEmergencyMode enables or disables emergency rate limiting mode
func (s *Service) SetEmergencyMode(enabled bool) {
	if s.tieredRateLimiter != nil {
		s.tieredRateLimiter.SetEmergencyMode(enabled)
	}
}

// CheckRateLimit performs comprehensive rate limiting check
func (s *Service) CheckRateLimit(ctx context.Context, userID, endpoint, clientIP string) (*auth.RateLimitResult, error) {
	if s.tieredRateLimiter == nil {
		// Return no-op result if rate limiter is not available
		return &auth.RateLimitResult{Allowed: true}, nil
	}
	return s.tieredRateLimiter.CheckRateLimit(ctx, userID, endpoint, clientIP)
}

// GetUserRateLimitStatus returns current rate limit status for a user
func (s *Service) GetUserRateLimitStatus(ctx context.Context, userID string) (map[string]*models.RateLimitInfo, error) {
	if s.tieredRateLimiter == nil {
		return nil, fmt.Errorf("rate limiting not available")
	}
	return s.tieredRateLimiter.GetUserRateLimitStatus(ctx, userID)
}

// GetIPRateLimitStatus returns current rate limit status for an IP
func (s *Service) GetIPRateLimitStatus(ctx context.Context, clientIP string) (map[string]*models.RateLimitInfo, error) {
	if s.tieredRateLimiter == nil {
		return nil, fmt.Errorf("rate limiting not available")
	}
	return s.tieredRateLimiter.GetIPRateLimitStatus(ctx, clientIP)
}

// ResetUserRateLimit resets rate limits for a specific user and rate type
func (s *Service) ResetUserRateLimit(ctx context.Context, userID, rateType string) error {
	if s.tieredRateLimiter == nil {
		return fmt.Errorf("rate limiting not available")
	}
	return s.tieredRateLimiter.ResetUserRateLimit(ctx, userID, rateType)
}

// ResetIPRateLimit resets rate limits for a specific IP and endpoint
func (s *Service) ResetIPRateLimit(ctx context.Context, clientIP, endpoint string) error {
	if s.tieredRateLimiter == nil {
		return fmt.Errorf("rate limiting not available")
	}
	return s.tieredRateLimiter.ResetIPRateLimit(ctx, clientIP, endpoint)
}

// UpdateTierLimits updates limits for a specific tier
func (s *Service) UpdateTierLimits(tier models.UserTier, limits auth.TierConfig) {
	if s.tieredRateLimiter != nil {
		s.tieredRateLimiter.UpdateTierLimits(tier, limits)
	}
}

// UpdateEndpointConfig updates configuration for a specific endpoint
func (s *Service) UpdateEndpointConfig(endpoint string, config auth.EndpointConfig) {
	if s.tieredRateLimiter != nil {
		s.tieredRateLimiter.UpdateEndpointConfig(endpoint, config)
	}
}

// UpdateRateLimitConfig updates the rate limit configuration
func (s *Service) UpdateRateLimitConfig(config *auth.RateLimitConfig) {
	if s.tieredRateLimiter != nil {
		s.tieredRateLimiter.UpdateConfig(config)
	}
}

// GetRateLimitConfig returns the current rate limit configuration
func (s *Service) GetRateLimitConfig() *auth.RateLimitConfig {
	if s.tieredRateLimiter == nil {
		return nil
	}
	return s.tieredRateLimiter.GetConfig()
}

// StartBackgroundCleanup starts a background goroutine for periodic cleanup
func (s *Service) StartBackgroundCleanup(ctx context.Context) {
	if s.tieredRateLimiter != nil {
		s.tieredRateLimiter.StartBackgroundCleanup(ctx)
	}
}

// CleanupExpiredData removes expired rate limit data
func (s *Service) CleanupExpiredData(ctx context.Context) error {
	if s.tieredRateLimiter == nil {
		return fmt.Errorf("rate limiting not available")
	}
	return s.tieredRateLimiter.CleanupExpiredData(ctx)
}

// Start starts all sub-services
func (s *Service) Start(ctx context.Context) error {
	s.logger.Info("Starting unified user authentication service")
	// Add any initialization logic here
	return nil
}

// Stop stops all sub-services
func (s *Service) Stop(ctx context.Context) error {
	s.logger.Info("Stopping unified user authentication service")
	// Add any cleanup logic here
	return nil
}

// Service accessor methods for enterprise components

// AuditService returns the audit service
func (s *Service) AuditService() *audit.Service {
	return s.auditService
}

// NotificationService returns the notification service
func (s *Service) NotificationService() *notification.Service {
	return s.notificationService
}

// PasswordService returns the password service
func (s *Service) PasswordService() *password.Service {
	return s.passwordService
}

// ComplianceService returns the compliance service
func (s *Service) ComplianceService() *compliance.Service {
	return s.complianceService
}

// EncryptionService returns the encryption service
func (s *Service) EncryptionService() *encryption.Service {
	return s.encryptionService
}

// TwoFAService returns the 2FA service
func (s *Service) TwoFAService() *twofa.Service {
	return s.twoFAService
}

// Enterprise Business Logic Methods

// RegisterUserWithCompliance performs enterprise-grade user registration with full compliance
func (s *Service) RegisterUserWithCompliance(ctx context.Context, req *EnterpriseRegistrationRequest) (*EnterpriseRegistrationResponse, error) {
	// Validate and sanitize input
	if err := s.validateRegistrationInput(req); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Check compliance requirements
	complianceResult, err := s.complianceService.CheckCompliance(ctx, &compliance.ComplianceRequest{
		Email:   req.Email,
		Country: req.Country,
		IPAddress: req.IPAddress,
	})
	if err != nil {
		return nil, fmt.Errorf("compliance check failed: %w", err)
	}

	// Validate password against enterprise policy
	userInfo := map[string]string{
		"email":      req.Email,
		"firstName":  req.FirstName,
		"lastName":   req.LastName,
		"username":   req.Username,
	}
	
	passwordResult := s.passwordService.ValidatePassword(ctx, req.Password, userInfo, nil)
	if !passwordResult.IsValid {
		return nil, fmt.Errorf("password validation failed: %s", passwordResult.Errors[0])
	}

	// Hash password
	hashedPassword, err := s.passwordService.HashPassword(req.Password)
	if err != nil {
		return nil, fmt.Errorf("password hashing failed: %w", err)
	}

	// Create user through auth service
	user, err := s.authService.CreateUser(ctx, &auth.CreateUserRequest{
		Email:     req.Email,
		Username:  req.Username,
		Password:  hashedPassword,
		FirstName: req.FirstName,
		LastName:  req.LastName,
		Country:   req.Country,
	})
	if err != nil {
		return nil, fmt.Errorf("user creation failed: %w", err)
	}

	// Send verification emails
	go s.notificationService.SendEmailVerification(ctx, user.ID, user.Email)
	
	// Initialize KYC if required
	if complianceResult.KYCRequired {
		go func() {
			kycLevel := kyc.KYCLevelBasic
			if complianceResult.RequiredKYCLevel == "enhanced" {
				kycLevel = kyc.KYCLevelAdvanced
			}
			s.kycService.InitiateKYC(ctx, user.ID, kycLevel)
		}()
	}

	// Log registration event
	s.auditService.LogEvent(ctx, audit.EventUserRegistered, audit.RiskLevelLow, audit.AuditContext{
		UserID:    user.ID,
		IPAddress: req.IPAddress,
		UserAgent: req.UserAgent,
		Metadata: map[string]interface{}{
			"email":       req.Email,
			"country":     req.Country,
			"kyc_required": complianceResult.KYCRequired,
		},
	}, "User registration completed")

	return &EnterpriseRegistrationResponse{
		UserID:                   user.ID,
		Email:                    user.Email,
		Username:                 user.Username,
		TwoFactorGracePeriod:     s.config.TwoFAGracePeriodDays,
		EmailVerificationRequired: true,
		PhoneVerificationRequired: req.PhoneNumber != "",
		ComplianceFlags:          complianceResult.Flags,
		NextSteps: []string{
			"Verify email address",
			"Set up two-factor authentication",
			"Complete identity verification",
		},
		CreatedAt: user.CreatedAt,
	}, nil
}

// AuthenticateWithMFA performs multi-factor authentication
func (s *Service) AuthenticateWithMFA(ctx context.Context, req *MFAAuthRequest) (*auth.TokenPair, error) {
	// First authenticate with password
	tokenPair, user, err := s.authService.AuthenticateUser(ctx, req.Email, req.Password)
	if err != nil {
		return nil, err
	}

	// Check if 2FA is enabled
	twoFAEnabled, err := s.twoFAService.IsTwoFactorEnabled(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to check 2FA status: %w", err)
	}

	if twoFAEnabled {
		// Verify 2FA token
		if req.TwoFactorToken == "" {
			return nil, fmt.Errorf("two-factor authentication token required")
		}

		verified, err := s.twoFAService.VerifyTOTP(ctx, user.ID, req.TwoFactorToken)
		if err != nil || !verified {
			// Log failed 2FA attempt
			s.auditService.LogEvent(ctx, audit.EventTwoFactorFailed, audit.RiskLevelHigh, audit.AuditContext{
				UserID:    user.ID,
				IPAddress: req.IPAddress,
				UserAgent: req.UserAgent,
			}, "2FA verification failed")
			return nil, fmt.Errorf("invalid two-factor authentication token")
		}
	} else {
		// Check if 2FA enforcement is required
		enforced, err := s.twoFAService.EnforceTwoFactor(ctx, user.ID, s.config.TwoFAGracePeriodDays)
		if err != nil {
			return nil, fmt.Errorf("failed to check 2FA enforcement: %w", err)
		}
		if !enforced {
			return nil, fmt.Errorf("two-factor authentication setup required")
		}
	}

	// Log successful authentication
	s.auditService.LogEvent(ctx, audit.EventUserLogin, audit.RiskLevelLow, audit.AuditContext{
		UserID:    user.ID,
		IPAddress: req.IPAddress,
		UserAgent: req.UserAgent,
		Metadata: map[string]interface{}{
			"mfa_used": twoFAEnabled,
		},
	}, "User authentication successful")

	return tokenPair, nil
}

// EnterpriseRegistrationRequest represents a complete user registration request
type EnterpriseRegistrationRequest struct {
	Email       string `json:"email" validate:"required,email"`
	Username    string `json:"username" validate:"required,min=3,max=30"`
	Password    string `json:"password" validate:"required,min=8"`
	FirstName   string `json:"first_name" validate:"required,min=1,max=50"`
	LastName    string `json:"last_name" validate:"required,min=1,max=50"`
	PhoneNumber string `json:"phone_number" validate:"omitempty,e164"`
	Country     string `json:"country" validate:"required,len=2"`
	IPAddress   string `json:"ip_address"`
	UserAgent   string `json:"user_agent"`
}

// EnterpriseRegistrationResponse represents the registration response
type EnterpriseRegistrationResponse struct {
	UserID                    uuid.UUID `json:"user_id"`
	Email                     string    `json:"email"`
	Username                  string    `json:"username"`
	TwoFactorGracePeriod     int       `json:"two_factor_grace_period_days"`
	EmailVerificationRequired bool      `json:"email_verification_required"`
	PhoneVerificationRequired bool      `json:"phone_verification_required"`
	ComplianceFlags          []string  `json:"compliance_flags"`
	NextSteps                []string  `json:"next_steps"`
	CreatedAt                time.Time `json:"created_at"`
}

// MFAAuthRequest represents a multi-factor authentication request
type MFAAuthRequest struct {
	Email           string `json:"email" validate:"required,email"`
	Password        string `json:"password" validate:"required"`
	TwoFactorToken  string `json:"two_factor_token,omitempty"`
	IPAddress       string `json:"ip_address"`
	UserAgent       string `json:"user_agent"`
}

// validateRegistrationInput validates the registration input
func (s *Service) validateRegistrationInput(req *EnterpriseRegistrationRequest) error {
	if req.Email == "" {
		return fmt.Errorf("email is required")
	}
	if req.Username == "" {
		return fmt.Errorf("username is required")
	}
	if req.Password == "" {
		return fmt.Errorf("password is required")
	}
	if req.FirstName == "" {
		return fmt.Errorf("first name is required")
	}
	if req.LastName == "" {
		return fmt.Errorf("last name is required")
	}
	if req.Country == "" {
		return fmt.Errorf("country is required")
	}
	return nil
}
